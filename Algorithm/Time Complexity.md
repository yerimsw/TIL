### 알고리즘 분석이 필요한 이유

-   문제를 해결할 수 있는 알고리즘은 많지만, 여기서 도전과제는 가장 효율적인 알고리즘을 찾는 것이다.
-   어떻게 서로 다른 알고리즘, 프로그램들의 효율성을 따져볼 수 있을까?


### 시간 복잡도와 공간 복잡도

-   공간 복잡도 - 알고리즘에 의해 요구되는 컴퓨터의 메모리 양.
-   시간 복잡도 - 프로그램 동작에 있어 실행되는 연산의 수.
-   왜 실제 걸리는 시간을 측정하지 않고 연산의 수를 측정하는 것일까?
-   코드를 실행하는 것은 컴파일러, 프로세서 등 여러 외부 요인들에 의해 영향을 받기 때문에, 실제 걸리는 시간을 측정하기 보다 특정 명령이 실행되는 횟수를 측정한다.


### 빅 오 표기법 (Big-O Notation)

-   시간복잡도를 나타내는 표기법으로 빅 오, 빅 오메가, 빅 세타가 있다.
-   이 중 빅 오 표기법은 최악의 경우를 고려했을 때의 시간 복잡도를 나타낸다.
-   주로 알고리즘의 효율성을 따질 때 빅 오 표기법을 활용하는데, 그 이유는 무엇일까?
-   최악의 경우에 대해 표기하기 때문에, 연산 실행의 모든 경우의 수가 해당 범위 내에 들어오기 때문이다.
-   또한 알고리즘의 입력 값에 따른 효율성 추이를 판단하는 데도 도움이 된다.


### 빅 오 표기법 사용법

```
for (i=0; i<n; i++) { 
	ThisSum = 0;
	for (j=i; j<n; j++) {
		ThisSum = ThisSum + A[j];
	} 
}
```

> 👉 1 + n x (1 + 1 + n x (1)) = 1 + 2n + n^2  
> 👉 O(n^2 + 2n + 1) = O(n^2)

-   위 코드 상 컴퓨터가 실행하는 연산의 개수를 식으로 표현하면 n^2 + 2n + 1 가 되고 n^2에 비례한다.
-   Big-O 표기법에 따라 대표항인 n^2만을 남겨두고 고려하면 시간복잡도는 O(n^2)이 된다.
-   이때 대표항을 제외한 항, 대표항의 계수도 없애준다.
